1. javscript数据类型
   答：基本类型(6个)：String/Number/Boolean/Undefined/Null/Symbol
      混合类型：Object
2. 简述react diff
   答：它希望抽象虚拟DOM，对虚拟DOM的比较减少对DOM的重绘和重排。
   主要是根据type/props来判断是否需要更新，比较主要是判断类型-》判断属性-》递归
   策略：
   1. 同级比较
   2. 类型的比较（组件比较）
   3. Key比较
   a. 原生节点->元素层级：
        元素类型相同的情况，保留原DOM节点，根据props属性更新有改变的属性， 更新操作；
        元素类型不同的情况，传过来的是null, 删除dom; 不为null， 替换操作；删除原有的树，建立新的树。
        处理完毕后，对子节点进行递归
   b. 组件层级
        组件实例相同的情况，调用render时，diff算法将之前的结果和新的结果进行递归；
        组件实例不同的情况，删除原有的实例树
   c. key, React根据原有的key来匹配, key相同，比较索引值，索引值变大的进行移动，变小的不管

3. hooks思想
   hooks是以函数组件的形式，副作用state和生命周期的特性的函数，能够抽象公共逻辑

4. var/let/const区别（5点）
   a. 常量const/变量var、let
   b. 变量提升var, let/const不存在变量提升
   c. 暂时性死区（声明前不可用， let/const）
   d. 重复声明（var可以，后面两个不行）
   e. 块级作用域(let/const), var（全局/函数作用域）

5. 浏览器内核
6. 多线程（线程/任务队列/同步等问题）
    进程可以包括多个线程，由线程去完成任务。
   js单线程的原因：历史遗留问题，如果多线程，一个编辑DOM一个删除DOM, 此时不能确定应该使用哪种操作合适。
   同步任务：在主线程排队的任务，只有前一个任务结束，才能继续往下执行。
   异步任务：不进入主线程，而是进入“异步队列”的任务，当“异步任务”同住主进程，某个异步可以执行了，该任务才会进入到主线程执行。
7. websocket/webwork
8. 组件：图片处理组件/公共util库/table多层嵌套组件
9. 优化：
   浏览器加载：
     图片域名问题浏览器请求6个，分摊服务排队压力/大小w_,
  
   内存问题：
      node.js处理数据：JSON.parse放在客户端处理

   编译速度：
      webpack: hard-source-webpack-plugin
      
   打包大小：
      lodash按需引入：1. import debounce from 'lodash/debounce', 2.webpack相关配置 lodash-webpack 和 babel-plugin-lodash
      moment-> dayjs
 10. js算法（递归、冒泡、红二叉树、堆栈）
 11. token/session/cookie/localStorage/sessionStorage
      cookie是存储在浏览器中的，session是存储在服务器端的，浏览器发出请求，带上的cookie里有sessionId信息，session获取后能校验。cookie有大小限制，不超过4KB，session没有大小限制
      localStorage/sessionStorage都是保存在浏览器端的，sessionStorage会话期间有效，关闭就结束；localStorage是一直存在，除非手动清除
 12. Set（去重）
 13. 堆/栈/堆栈/链表
     栈stack第一种含义是一种数据的存放方式，特点为LIFO，后进先出（Last in, first out）
     stack第二种含义是“调用栈”，程序运行时，总是先完成最上层的调用，然后将它的值返回到下一层调用，直到调用栈结束，返回结果。
     stack第三种含义是存放数据的一种内存区域，系统划分不同的内存空间：stack(栈)和heap(堆)。stack是有结构的，每个区块按照一定次序存放，可以明确知道每个区块大小；heap是没有结构的，数据可以任意存放。因此, stack的寻址速度要快于heap。每个线程分配一个stack, 每个进程分配一个heap。stack是线程独占的，heap是线程共享的。此外，stack创建时，大小确定，超过这个大小就会发生stack overflow错误，而heap的大小不确定，可以随时增加。
  14. webpack如何区分环境打包/webpack优化
      package.json里执行命令加NODE_ENV， 
      window上不支持NODE_ENV的使用，为了兼容采用cross-env
  15. typescript，范型
      范型是为了解决多重类型重用的问题，这样用户可以以自己的数据类型来使用组件
  16. 设计双击事件/拖动如何实现/原生阻止冒泡/右键菜单跟随
      阻止事件冒泡：React-> e.stopPropogation, 原生 -> e.preventDefault
      右键菜单跟随：
          右键oncontextmenu
      双击事件： 会触发2次单击+一次双击
  17. 判断对象是否有某个属性/判断是否是数组（原生）/
      Object.hasOwnProperty/perperty in object
      arr instanceOf Array/ arr.constructor === Array/Object.prototype.toString/Array.isArray
  18. React-router子组件是如何获取到参数的/父子组件交互，包括数据和方法
  19. 解决跨域的方法
  20. 9.18默哀，置灰页面
      filter: grayscale(100%)

  21. [动态插入JS的方法，及defer/async的区别](https://javascript.info/script-async-defer)
      document.write/标签的形式
      js的获取都是异步获取的，默认是会阻止DOM的绘制，直到js结束后继续绘制。
      但是加入defer后，不会阻止DOM的绘制， defer加入后的执行，是在DOM绘制已经准备好，在DOMContentLoaded之前完成。
      defer是不按照顺序下载js，可能后面的脚本先下载完成，但按顺序执行脚本。

      async也不会阻止DOM的绘制，async和DOMContentLoaded之前没有执行先后关系，是随机获取js， js的运行顺序是先下载先执行

      <img src="https://github.com/xiaosunJessica/interview/blob/master/images/defer-async.png" alt="图1" title="图1" width="300" height="300" /> 

  22. antd confirm实现
      Modal.confirm ，调用通过Document.body.appendChild把Modal容器挂上去，通过render方式把内容放在容器上
  23. 缓存
      
  24. 箭头函数的this, context表示意义
  25. 宏任务/微任务，setTimeout/Promise
  26. css变量表示， less的mixin
      sass变量是$, less变量是@, css是--
  27. react hooks挂在内存哪里/ React.memo / React.pureComponent / 高阶组件
      高阶组件：React.memo。
      React.PureComponent继承自React.PureComponent, 对state/props进行浅比较，仅可用于ClassComponent.
      React.Memo功能同React.PureComponent, 对props进行浅比较，但它是高阶组件，可用于ClassComponent，也可用于FunctionComponent

  28. useRef和常用变量区别/useMemo
  29. display:none/visibility: hidden区别，重绘repaint和回流reflow
      display:none是会从文档中消失，不占位置；visibility:hidden是在文档中依然存在，占用位置。
      visibility:hidden的性能比display:none的好，visibility的变化不会引起文档的回流。display的变化会改变页面布局，会产生回流。
      回流：是引起DOM树结构变化的，页面布局变化的行为，回流一定会导致重绘
      重绘：不会引起DOM树变化的，页面布局变化的行为
      
